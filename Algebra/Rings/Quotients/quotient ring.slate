%../../../../../logics/hlm%

[
  $~Carrier = $../Carrier,
  $~"Cartesian product" = $../../../Essentials/Sets/"Cartesian product",
  $~"Equivalence classes" = $../../../Essentials/Relations/"Equivalence classes",
  $~Functions = $../../../Essentials/Functions/Functions,
  $~Rings = $../Rings,
  $~sum = $../sum
]

/**
 * @references * https://en.wikipedia.org/wiki/Quotient_ring
 *             * https://mathworld.wolfram.com/QuotientRing.html
 *             * https://proofwiki.org/wiki/Definition:Quotient_Ring
 *             * https://ncatlab.org/nlab/show/quotient+ring
 *             * https://leanprover-community.github.io/mathlib_docs/ring_theory/ideal/basic.html#ideal.quotient.comm_ring
 */
$"quotient ring"(
  ğ‘: %Element($~Rings),
  I: %Subset($~Carrier(ğ‘ = ğ‘)),
  _1: %Constraint($../Ideals/ideal(ğ‘ = ğ‘, I = I)),
  âˆ¼: %Def($../../../Essentials/Relations/Endorelations(S = $~Carrier(ğ‘ = ğ‘)).relation(_1 = {
      #(g,h: %Element($~Carrier(ğ‘ = ğ‘))),
      {p = %exists(
        #(s: %Element(I)),
        formula = %equals(
          $~sum(ğ‘ = ğ‘, a = g, b = s),
          h
        )
      )}
  })),
  Q: %SetDef($~"Equivalence classes"(
    S = $~Carrier(ğ‘ = ğ‘),
    âˆ¼ = âˆ¼
  ))
): %ExplicitOperator {
  notation = $DivisionOperator(operands = [ğ‘, I]),
  definition = [$~Rings.ring(
    R = Q,
    âŠ• = $~Functions(
        X = $~"Cartesian product"(S = Q, T = Q),
        Y = Q
      ).function(_1 = {
        #(x: %Element($~"Cartesian product"(S = Q, T = Q))),
        {y = %structuralCases(
          x,
          $~"Cartesian product"(S = Q, T = Q),
          [{
            constructor = $~"Cartesian product".pair,
            parameters = #(
              _t: %Element(Q),
              _u: %Element(Q)
            ),
            value = %structuralCases(
              _t,
              $~"Equivalence classes"(
                S = $~Carrier(ğ‘ = ğ‘),
                âˆ¼ = âˆ¼
              ),
              [{
                constructor = $~"Equivalence classes".class,
                parameters = #(g: %Element($~Carrier(ğ‘ = ğ‘))),
                value = %structuralCases(
                  _u,
                  $~"Equivalence classes"(
                    S = $~Carrier(ğ‘ = ğ‘),
                    âˆ¼ = âˆ¼
                  ),
                  [{
                    constructor = $~"Equivalence classes".class,
                    parameters = #(h: %Element($~Carrier(ğ‘ = ğ‘))),
                    value = $~"Equivalence classes"(
                        S = $~Carrier(ğ‘ = ğ‘),
                        âˆ¼ = âˆ¼
                      ).class(s = $~sum(ğ‘ = ğ‘, a = g, b = h))
                  }]
                )
              }]
            )
          }]
        )}
    }),
    "0" = $~"Equivalence classes"(
        S = $~Carrier(ğ‘ = ğ‘),
        âˆ¼ = âˆ¼
      ).class(s = $../zero(ğ‘ = ğ‘)),
    âŠ– = $~Functions(X = Q, Y = Q).function(_1 = {
        #(t: %Element(Q)),
        {y = %structuralCases(
          t,
          $~"Equivalence classes"(
            S = $~Carrier(ğ‘ = ğ‘),
            âˆ¼ = âˆ¼
          ),
          [{
            constructor = $~"Equivalence classes".class,
            parameters = #(g: %Element($~Carrier(ğ‘ = ğ‘))),
            value = $~"Equivalence classes"(
                S = $~Carrier(ğ‘ = ğ‘),
                âˆ¼ = âˆ¼
              ).class(s = $../"additive inverse"(ğ‘ = ğ‘, a = g))
          }]
        )}
    }),
    âŠ™ = $~Functions(
        X = $~"Cartesian product"(S = Q, T = Q),
        Y = Q
      ).function(_1 = {
        #(x: %Element($~"Cartesian product"(S = Q, T = Q))),
        {y = %structuralCases(
          x,
          $~"Cartesian product"(S = Q, T = Q),
          [{
            constructor = $~"Cartesian product".pair,
            parameters = #(
              t: %Element(Q),
              u: %Element(Q)
            ),
            value = %structuralCases(
              t,
              $~"Equivalence classes"(
                S = $~Carrier(ğ‘ = ğ‘),
                âˆ¼ = âˆ¼
              ),
              [{
                constructor = $~"Equivalence classes".class,
                parameters = #(g: %Element($~Carrier(ğ‘ = ğ‘))),
                value = %structuralCases(
                  u,
                  $~"Equivalence classes"(
                    S = $~Carrier(ğ‘ = ğ‘),
                    âˆ¼ = âˆ¼
                  ),
                  [{
                    constructor = $~"Equivalence classes".class,
                    parameters = #(h: %Element($~Carrier(ğ‘ = ğ‘))),
                    value = $~"Equivalence classes"(
                        S = $~Carrier(ğ‘ = ğ‘),
                        âˆ¼ = âˆ¼
                      ).class(s = $../product(ğ‘ = ğ‘, a = g, b = h))
                  }]
                )
              }]
            )
          }]
        )}
    }),
    "1" = $~"Equivalence classes"(
        S = $~Carrier(ğ‘ = ğ‘),
        âˆ¼ = âˆ¼
      ).class(s = $../one(ğ‘ = ğ‘))
  )]
}
