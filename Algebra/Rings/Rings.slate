%../../../../logics/hlm%

[
  $~Functions = $../../Essentials/Functions/Functions,
  $~"Inner operations" = $../../Essentials/Operations/"Inner operations",
  $~Operations = $../../Essentials/Operations/Operations,
  $~"element condition" = $../Generic/Isomorphisms/"element condition",
  $~"inner operation condition" = $../Generic/Isomorphisms/"inner operation condition"
]

/**
 * @references * https://en.wikipedia.org/wiki/Ring_(mathematics)
 *             * https://mathworld.wolfram.com/UnitRing.html
 *             * https://proofwiki.org/wiki/Definition:Ring_with_Unity
 *             * https://ncatlab.org/nlab/show/ring
 *             * https://coq.inria.fr/library/Coq.setoid_ring.Ring_theory.html#ring_theory
 *             * https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#ring
 */
$Rings: %Construction {
  $ring(
    R: %Set,
    âŠ•: %Element($~"Inner operations"(X = R)),
    "0": %Element(R),
    âŠ–: %Element($~Functions(X = R, Y = R)),
    âŠ™: %Element($~"Inner operations"(X = R)),
    "1": %Element(R),
    _1: %Constraint($ring(R = R, âŠ• = âŠ•, "0" = "0", âŠ– = âŠ–, âŠ™ = âŠ™, "1" = "1"))
  ): %Constructor {
    notation = $Tuple(
      items = [R, âŠ•, "0", âŠ–, âŠ™, "1"],
      style = '[]'
    ),
    equalityDefinition = {
      leftParameters = #(
        R: %Set,
        âŠ•: %Element($~"Inner operations"(X = R)),
        "0": %Element(R),
        âŠ–: %Element($~Functions(X = R, Y = R)),
        âŠ™: %Element($~"Inner operations"(X = R)),
        "1": %Element(R),
        _1: %Constraint($ring(R = R, âŠ• = âŠ•, "0" = "0", âŠ– = âŠ–, âŠ™ = âŠ™, "1" = "1"))
      ),
      rightParameters = #(
        S: %Set,
        â‹†: %Element($~"Inner operations"(X = S)),
        ğŸ¢: %Element(S),
        âˆ¼: %Element($~Functions(X = S, Y = S)),
        âˆ—: %Element($~"Inner operations"(X = S)),
        ğŸ£: %Element(S),
        _2: %Constraint($ring(R = S, âŠ• = â‹†, "0" = ğŸ¢, âŠ– = âˆ¼, âŠ™ = âˆ—, "1" = ğŸ£))
      ),
      definition = [%exists(
        #(Ï†: %Element($../../Essentials/Functions/Bijections(X = R, Y = S))),
        formula = %and(
          $~"inner operation condition"(X = R, Y = S, Ï† = Ï†, âˆ— = âŠ•, â‹† = â‹†),
          $~"element condition"(X = R, Y = S, Ï† = Ï†, x = "0", y = ğŸ¢),
          $../Generic/Isomorphisms/"function condition"(X = R, Y = S, Ï† = Ï†, f = âŠ–, g = âˆ¼),
          $~"inner operation condition"(X = R, Y = S, Ï† = Ï†, âˆ— = âŠ™, â‹† = âˆ—),
          $~"element condition"(X = R, Y = S, Ï† = Ï†, x = "1", y = ğŸ£)
        )
      )],
      isomorphic = %true
    }
  }

  notation = 'ğ“¡ğ“²ğ“·ğ“°',
  definitionNotation = {
    parameter = #(ğ‘: %Expr),
    singularName = 'ring',
    pluralName = 'rings'
  },
  rewrite = {
    parameter = #(ğ‘: %Element($Rings)),
    value = $Rings.ring(
      R = $Carrier(ğ‘ = ğ‘),
      âŠ• = $~Operations(
          X = $Carrier(ğ‘ = ğ‘),
          Y = $Carrier(ğ‘ = ğ‘),
          Z = $Carrier(ğ‘ = ğ‘)
        ).operation(_1 = {
          #(a,b: %Element($Carrier(ğ‘ = ğ‘))),
          {z = $sum(ğ‘ = ğ‘, a = a, b = b)}
      }),
      "0" = $zero(ğ‘ = ğ‘),
      âŠ– = $~Functions(
          X = $Carrier(ğ‘ = ğ‘),
          Y = $Carrier(ğ‘ = ğ‘)
        ).function(_1 = {
          #(a: %Element($Carrier(ğ‘ = ğ‘))),
          {y = $"additive inverse"(ğ‘ = ğ‘, a = a)}
      }),
      âŠ™ = $~Operations(
          X = $Carrier(ğ‘ = ğ‘),
          Y = $Carrier(ğ‘ = ğ‘),
          Z = $Carrier(ğ‘ = ğ‘)
        ).operation(_1 = {
          #(a,b: %Element($Carrier(ğ‘ = ğ‘))),
          {z = $product(ğ‘ = ğ‘, a = a, b = b)}
      }),
      "1" = $one(ğ‘ = ğ‘)
    )
  }
}
