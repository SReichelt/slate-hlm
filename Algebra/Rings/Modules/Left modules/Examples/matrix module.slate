%../../../../../../../logics/hlm%

[
  $~Carrier = $../../../Carrier,
  $~Matrices = $../../../Matrices/Matrices,
  $~"Natural numbers" = $../../../../../Essentials/Numbers/Natural/"Natural numbers",
  $~Operations = $../../../../../Essentials/Operations/Operations
]

/**
 * @references * https://leanprover-community.github.io/mathlib_docs/data/matrix/basic.html#matrix.module
 */
$"matrix module"(
  ğ‘: %Element($../../../Rings),
  m,n: %Element($~"Natural numbers")
): %ExplicitOperator {
  notation = $SubSup(
    body = ğ‘,
    sup = $MultiplicationOperator(
      symbol = 'Ã—',
      operands = [m, n]
    )
  ),
  definition = [$../"Left modules"(ğ‘ = ğ‘).module(
      M = $~Matrices(ğ‘ = ğ‘, m = m, n = n),
      âŠ• = $~Operations(
          X = $~Matrices(ğ‘ = ğ‘, m = m, n = n),
          Y = $~Matrices(ğ‘ = ğ‘, m = m, n = n),
          Z = $~Matrices(ğ‘ = ğ‘, m = m, n = n)
        ).operation(_1 = {
          #(A,B: %Element($~Matrices(ğ‘ = ğ‘, m = m, n = n))),
          {z = $../../../Matrices/sum(ğ‘ = ğ‘, m = m, n = n, A = A, B = B)}
      }),
      "0" = $../../../Matrices/zero(ğ‘ = ğ‘, m = m, n = n),
      âŠ– = $../../../../../Essentials/Functions/Functions(
          X = $~Matrices(ğ‘ = ğ‘, m = m, n = n),
          Y = $~Matrices(ğ‘ = ğ‘, m = m, n = n)
        ).function(_1 = {
          #(A: %Element($~Matrices(ğ‘ = ğ‘, m = m, n = n))),
          {y = $../../../Matrices/"additive inverse"(ğ‘ = ğ‘, m = m, n = n, A = A)}
      }),
      âŠ™ = $~Operations(
          X = $~Carrier(ğ‘ = ğ‘),
          Y = $~Matrices(ğ‘ = ğ‘, m = m, n = n),
          Z = $~Matrices(ğ‘ = ğ‘, m = m, n = n)
        ).operation(_1 = {
          #(
            r: %Element($~Carrier(ğ‘ = ğ‘)),
            A: %Element($~Matrices(ğ‘ = ğ‘, m = m, n = n))
          ),
          {z = $../../../Matrices/"product with left scalar"(ğ‘ = ğ‘, m = m, n = n, r = r, A = A)}
      })
  )]
}
