%../../../../../logics/hlm%

[
  $~Carrier = $../Carrier,
  $~"Cartesian product" = $../../../Essentials/Sets/"Cartesian product",
  $~"Equivalence classes" = $../../../Essentials/Relations/"Equivalence classes",
  $~Functions = $../../../Essentials/Functions/Functions,
  $~Groups = $../Groups,
  $~operation = $../operation
]

/**
 * @references * https://en.wikipedia.org/wiki/Quotient_group
 *             * https://mathworld.wolfram.com/QuotientGroup.html
 *             * https://proofwiki.org/wiki/Definition:Quotient_Group
 *             * https://ncatlab.org/nlab/show/quotient+group
 *             * https://leanprover-community.github.io/mathlib_docs/group_theory/quotient_group.html#quotient_group.group
 */
$"quotient group"(
  ğ†: %Element($~Groups),
  S: %Subset($~Carrier(ğ† = ğ†)),
  _1: %Constraint($../Subgroups/"normal subgroup set"(ğ† = ğ†, S = S)),
  âˆ¼: %Def($../../../Essentials/Relations/Endorelations(S = $~Carrier(ğ† = ğ†)).relation(_1 = {
      #(g,h: %Element($~Carrier(ğ† = ğ†))),
      {p = %exists(
        #(s: %Element(S)),
        formula = %equals(
          $~operation(ğ† = ğ†, a = g, b = s),
          h
        )
      )}
  })),
  Q: %SetDef($~"Equivalence classes"(
    S = $~Carrier(ğ† = ğ†),
    âˆ¼ = âˆ¼
  ))
): %ExplicitOperator {
  notation = $DivisionOperator(operands = [ğ†, S]),
  definition = [$~Groups.group(
    G = Q,
    âˆ— = $~Functions(
        X = $~"Cartesian product"(S = Q, T = Q),
        Y = Q
      ).function(_1 = {
        #(x: %Element($~"Cartesian product"(S = Q, T = Q))),
        {y = %structuralCases(
          x,
          $~"Cartesian product"(S = Q, T = Q),
          [{
            constructor = $~"Cartesian product".pair,
            parameters = #(
              t: %Element(Q),
              u: %Element(Q)
            ),
            value = %structuralCases(
              t,
              $~"Equivalence classes"(
                S = $~Carrier(ğ† = ğ†),
                âˆ¼ = âˆ¼
              ),
              [{
                constructor = $~"Equivalence classes".class,
                parameters = #(g: %Element($~Carrier(ğ† = ğ†))),
                value = %structuralCases(
                  u,
                  $~"Equivalence classes"(
                    S = $~Carrier(ğ† = ğ†),
                    âˆ¼ = âˆ¼
                  ),
                  [{
                    constructor = $~"Equivalence classes".class,
                    parameters = #(h: %Element($~Carrier(ğ† = ğ†))),
                    value = $~"Equivalence classes"(
                        S = $~Carrier(ğ† = ğ†),
                        âˆ¼ = âˆ¼
                      ).class(s = $~operation(ğ† = ğ†, a = g, b = h))
                  }]
                )
              }]
            )
          }]
        )}
    }),
    e = $~"Equivalence classes"(
        S = $~Carrier(ğ† = ğ†),
        âˆ¼ = âˆ¼
      ).class(s = $../identity(ğ† = ğ†)),
    i = $~Functions(X = Q, Y = Q).function(_1 = {
        #(t: %Element(Q)),
        {y = %structuralCases(
          t,
          $~"Equivalence classes"(
            S = $~Carrier(ğ† = ğ†),
            âˆ¼ = âˆ¼
          ),
          [{
            constructor = $~"Equivalence classes".class,
            parameters = #(g: %Element($~Carrier(ğ† = ğ†))),
            value = $~"Equivalence classes"(
                S = $~Carrier(ğ† = ğ†),
                âˆ¼ = âˆ¼
              ).class(s = $../inverse(ğ† = ğ†, a = g))
          }]
        )}
    })
  )]
}
