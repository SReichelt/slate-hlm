%../../../../../logics/hlm%

/**
 * @remarks This somewhat technical construction exposes the equality relation on `S[i = {i}]` in such a way that it becomes possible to ask whether `%equals(s, t)` for `%in(s, S[i = {a}])` and `%in(t, S[i = {b}])` whenever a `%equals(a, b)`.
 *
 *          It might seem that asking whether `%equals(s, t)` should simply be allowed in this case, but the type system of HLM restricts it to the case when `a` and `b` are literally the same expression. If `%equals(a, b)` is given as a proposition, the equality can carry information that needs to be transported from `I` to `S`.
 *
 *          E.g. in category theory, `I` may be a set of objects (which are equal whenever they are isomorphic), and `S[i = {i}]` may be a set of morphisms from or to `i`. To check whether two of these morphisms are equal, one of them first needs to be composed with a specific isomorphism.
 *
 *          Dependent equality is a prerequisite to formalizing arbitrary disjoint unions (see `$../../Sets/"Generalized operators"/"Generalized disjoint union"`).
 */
$"Dependent equality"(
  I: %Set,
  _i: %Binder(
    #(i: %Element(I)),
    #(S: %Set)
  )
): %Construction {
  $equality(
    _a: %Binder(
      #(
        a,b: %Element(I),
        _1: %Constraint(%equals(a, b))
      ),
      #(‚â°: %Element($../Relations(
        S = {S[i = {a}]},
        T = {S[i = {b}]}
      )))
    ),
    _2: %Constraint(%forall(
      #(i: %Element(I)),
      %equals(
        ‚â°[a = {i}, b = {i}],
        $../equality(S = {S[i = {i}]})
      )
    ))
  ): %Constructor {
    notation = $SubSup(
      body = $Parens(
        body = ‚â°,
        style = '()'
      ),
      sub = $EqualityRelation(operands = [a, b]),
      sup = $SubSup(
        body = $Parens(
          body = S,
          style = '()'
        ),
        sub = $ElementParameter(
          variable = i,
          set = I
        )
      )
    ),
    equalityDefinition = {
      leftParameters = #(
        _a: %Binder(
          #(
            a,b: %Element(I),
            _1: %Constraint(%equals(a, b))
          ),
          #(‚â°: %Element($../Relations(
            S = {S[i = {a}]},
            T = {S[i = {b}]}
          )))
        ),
        _2: %Constraint(%forall(
          #(i: %Element(I)),
          %equals(
            ‚â°[a = {i}, b = {i}],
            $../equality(S = {S[i = {i}]})
          )
        ))
      ),
      rightParameters = #(
        _a: %Binder(
          #(
            a,b: %Element(I),
            _1: %Constraint(%equals(a, b))
          ),
          #("‚â°'": %Element($../Relations(
            S = {S[i = {a}]},
            T = {S[i = {b}]}
          )))
        ),
        "_2'": %Constraint(%forall(
          #(i: %Element(I)),
          %equals(
            "‚â°'"[a = {i}, b = {i}],
            $../equality(S = {S[i = {i}]})
          )
        ))
      ),
      definition = [%forall(
        #(a,b: %Element(I)),
        %equals(‚â°[a = {a}, b = {b}], "‚â°'"[a = {a}, b = {b}])
      )],
      isomorphic = %true
    }
  }

  notation = $Function(
    function = 'ùììùìÆùìπùìîùì∫',
    arguments = [$SubSup(
      body = $Parens(
        body = S,
        style = '()'
      ),
      sub = $ElementParameter(
        variable = i,
        set = I
      )
    )]
  ),
  definitionNotation = {
    parameter = #(‚âÉ: %Expr),
    singularName = [
      'dependent equality',
      ' on ',
      S,
      ' ',
      $Parens(
        body = $ElementParameter(
          variable = i,
          set = I
        ),
        style = '()'
      )
    ],
    pluralName = [
      'dependent equalities',
      ' on ',
      S,
      ' ',
      $Parens(
        body = $ElementParameter(
          variable = i,
          set = I
        ),
        style = '()'
      )
    ]
  }
}
