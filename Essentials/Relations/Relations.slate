%../../../../logics/hlm%

/**
 * @remarks This definition encodes a relation from `S` to `T` as a proposition depending on an element of `S` and an element of `T` (up to equivalence). It would be equally possible to encode relations as subsets of the Cartesian product; the given definition is just more convenient.
 *
 * @references * https://en.wikipedia.org/wiki/Binary_relation
 *             * https://mathworld.wolfram.com/Relation.html
 *             * https://proofwiki.org/wiki/Definition:Relation
 *             * https://ncatlab.org/nlab/show/relation#binary_relations
 *             * https://leanprover-community.github.io/mathlib_docs/data/rel.html#rel
 */
$Relations(
  S: %Set(auto = %true),
  T: %Set(auto = %true)
): %Construction {
  $relation(s: %Binding(
    S,
    #(t: %Binding(
      T,
      #(p: %Prop)
    ))
  )): %Constructor {
    notation = $SubSup(
      body = $Parens(
        body = p,
        style = '[]'
      ),
      sub = $Group(items = [
        $ElementRelation(operands = [s, S]),
        $ElementRelation(operands = [t, T])
      ])
    ),
    equalityDefinition = {
      leftParameters = #(s: %Binding(
        S,
        #(t: %Binding(
          T,
          #(p: %Prop)
        ))
      )),
      rightParameters = #(s: %Binding(
        S,
        #(t: %Binding(
          T,
          #(q: %Prop)
        ))
      )),
      definition = [%forall(
        #(
          s: %Element(S),
          t: %Element(T)
        ),
        %equiv(p[s,t], q[s,t])
      )],
      isomorphic = %true
    }
  }

  notation = $Function(
    function = 'ùì°ùìÆùìµ',
    arguments = [S, T]
  ),
  definitionNotation = {
    parameter = #(‚â∫: %Expr),
    singularName = ['relation', ' from ', S, ' to ', T],
    pluralName = ['relations', ' from ', S, ' to ', T]
  }
}
